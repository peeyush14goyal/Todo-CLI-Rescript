// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Int = require("bs-platform/lib/js/belt_Int.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

var getToday = (function() {
  let date = new Date();
  return new Date(date.getTime() - (date.getTimezoneOffset() * 60000))
    .toISOString()
    .split("T")[0];
});

var encoding = "utf8";

var pendingTodosFile = "todo.txt";

var completedTodosFile = "done.txt";

if (!Fs.existsSync(pendingTodosFile)) {
  Fs.writeFileSync(pendingTodosFile, "", {
        encoding: encoding,
        flag: "w"
      });
}

if (!Fs.existsSync(completedTodosFile)) {
  Fs.writeFileSync(completedTodosFile, "", {
        encoding: encoding,
        flag: "w"
      });
}

function readFile(filename) {
  if (!Fs.existsSync(filename)) {
    return [];
  }
  var text = Fs.readFileSync(filename, {
        encoding: "utf8",
        flag: "r"
      });
  var lines = text.split(Os.EOL);
  return lines.filter(function (text) {
              return text.length > 0;
            });
}

function appendFile(filename, text) {
  Fs.appendFileSync(filename, text, {
        encoding: "utf8",
        flag: "a"
      });
  
}

function writeFile(filename, lines) {
  var text = lines.join(Os.EOL);
  Fs.writeFileSync(filename, text, {
        encoding: encoding,
        flag: "w"
      });
  
}

function listOfTodos(param) {
  var data = readFile(pendingTodosFile);
  if (data.length !== 0) {
    var array = data.reverse();
    array.forEach(function (todo, index) {
          var index_val = String(array.length - index | 0);
          console.log("[" + index_val + "] " + todo);
          
        });
    return ;
  }
  console.log("There are no pending todos!");
  
}

function addTodo(todo) {
  appendFile(pendingTodosFile, todo + Os.EOL);
  console.log("Added todo: \"" + todo + "\"");
  
}

var usage = "Usage :-\n$ ./todo add \"todo item\"  # Add a new todo\n$ ./todo ls               # Show remaining todos\n$ ./todo del NUMBER       # Delete a todo\n$ ./todo done NUMBER      # Complete a todo\n$ ./todo help             # Show usage\n$ ./todo report           # Statistics";

function help(param) {
  console.log(usage);
  
}

function completed(index_val) {
  var data = readFile(pendingTodosFile);
  if (index_val > data.length || index_val < 1) {
    console.log("Error: todo #" + String(index_val) + " does not exist.");
    return ;
  }
  var todo = Caml_array.get(data, index_val - 1 | 0);
  appendFile(completedTodosFile, todo + Os.EOL);
  data.splice(index_val - 1 | 0, 1);
  writeFile(pendingTodosFile, data);
  console.log("Marked todo #" + String(index_val) + " as done.");
  
}

function deleteTodo(index_val) {
  var data = readFile(pendingTodosFile);
  if (index_val > data.length || index_val < 1) {
    console.log("Error: todo #" + String(index_val) + " does not exist. Nothing deleted.");
  } else {
    data.splice(index_val - 1 | 0, 1);
    writeFile(pendingTodosFile, data);
    console.log("Deleted todo #" + String(index_val));
  }
  
}

function report(param) {
  var pending = readFile(pendingTodosFile);
  var completed = readFile(completedTodosFile);
  var pending_count = String(pending.length);
  var completed_count = String(completed.length);
  console.log(Curry._1(getToday, undefined) + " Pending : " + pending_count + " Completed : " + completed_count);
  
}

function exeCommand(command) {
  if (typeof command === "number") {
    switch (command) {
      case /* Help */0 :
          console.log(usage);
          return ;
      case /* Report */1 :
          return report(undefined);
      case /* List */2 :
          return listOfTodos(undefined);
      
    }
  } else {
    switch (command.TAG | 0) {
      case /* Add */0 :
          var str = command._0;
          if (str !== undefined) {
            return addTodo(str);
          } else {
            console.log("Error: Missing todo string. Nothing added!");
            return ;
          }
      case /* Delete */1 :
          var index = command._0;
          if (index !== undefined) {
            return deleteTodo(index);
          } else {
            console.log("Error: Missing NUMBER for deleting todo.");
            return ;
          }
      case /* Done */2 :
          var index$1 = command._0;
          if (index$1 !== undefined) {
            return completed(index$1);
          } else {
            console.log("Error: Missing NUMBER for marking todo as done.");
            return ;
          }
      
    }
  }
}

function getType(argument, argv) {
  switch (argument) {
    case "add" :
        var value = Belt_Array.get(argv, 3);
        return {
                TAG: /* Add */0,
                _0: value
              };
    case "del" :
        var value$1 = Belt_Option.flatMap(Belt_Array.get(argv, 3), Belt_Int.fromString);
        return {
                TAG: /* Delete */1,
                _0: value$1
              };
    case "done" :
        var value$2 = Belt_Option.flatMap(Belt_Array.get(argv, 3), Belt_Int.fromString);
        return {
                TAG: /* Done */2,
                _0: value$2
              };
    case "ls" :
        return /* List */2;
    case "report" :
        return /* Report */1;
    default:
      return /* Help */0;
  }
}

if (process.argv.length < 3) {
  console.log(usage);
} else {
  var command = Caml_array.get(process.argv, 2);
  exeCommand(getType(command, process.argv));
}

exports.getToday = getToday;
exports.encoding = encoding;
exports.pendingTodosFile = pendingTodosFile;
exports.completedTodosFile = completedTodosFile;
exports.readFile = readFile;
exports.appendFile = appendFile;
exports.writeFile = writeFile;
exports.listOfTodos = listOfTodos;
exports.addTodo = addTodo;
exports.usage = usage;
exports.help = help;
exports.completed = completed;
exports.deleteTodo = deleteTodo;
exports.report = report;
exports.exeCommand = exeCommand;
exports.getType = getType;
/*  Not a pure module */
